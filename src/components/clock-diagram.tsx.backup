'use client';

import type { FC } from 'react';
import React, { useMemo, useState, useEffect, useCallback } from 'react';
import type { Task, Category } from '@/types';
import { timeToAngle, getSegmentPath, isDarkColor, timeToAngle12 } from '@/utils/color';
import { cn } from '@/lib/utils';

interface ClockDiagramProps {
  startTime: string;
  endTime: string;
  tasks: Task[];
  categories: Category[];
  timezone: string;
  onAddTask: (startTime: string) => void;
  onEditTask: (task: Task) => void;
  onDeleteTask?: (taskId: string) => void;
}

export const ClockDiagram: FC<ClockDiagramProps> = ({
  startTime,
  endTime,
  tasks,
  categories,
  timezone,
  onAddTask,
  onEditTask,
  onDeleteTask,
}) => {
  const [hoveredSegment, setHoveredSegment] = useState<string | null>(null);
  const [currentTime, setCurrentTime] = useState<Date>(new Date());
  const [isDragging, setIsDragging] = useState(false);

  useEffect(() => {
    const timer = setInterval(() => {
      setCurrentTime(new Date());
    }, 1000);

    return () => clearInterval(timer);
  }, []);

  const segments = useMemo(() => {
    const center = 180;
    const radius = 160;
    const innerRadius = radius * 0.4;
    const textRadius = radius * 0.7;

    return tasks.map(task => {
      const category = categories.find(c => c.name === task.categoryName);
      const color = category?.color || '#808080';
      const startAngle = timeToAngle(task.startTime, startTime, endTime);
      const endAngle = timeToAngle(task.endTime, startTime, endTime);
      const id = task.id;

      const path = getSegmentPath(center, center, radius, innerRadius, startAngle, endAngle);
      const midAngle = (startAngle + endAngle) / 2;
      const textX = center + textRadius * Math.cos((midAngle * Math.PI) / 180);
      const textY = center + textRadius * Math.sin((midAngle * Math.PI) / 180);
      const textRotation = midAngle > 90 && midAngle < 270 ? midAngle + 180 : midAngle;

      return {
        id,
        path,
        color,
        textX,
        textY,
        textRotation,
        name: task.name,
        originalTask: task,
        startAngle,
        endAngle,
      };
    });
  }, [tasks, categories, startTime, endTime]);

  const handleSegmentClick = useCallback((task: Task) => {
    onEditTask(task);
  }, [onEditTask]);

  const handleBackgroundClick = useCallback((event: React.MouseEvent<SVGElement>) => {
    if (isDragging) return;

    const svgRect = event.currentTarget.getBoundingClientRect();
    const center = { x: svgRect.width / 2, y: svgRect.height / 2 };
    const clickX = event.clientX - svgRect.left;
    const clickY = event.clientY - svgRect.top;

    const angle = Math.atan2(clickY - center.y, clickX - center.x) * (180 / Math.PI);
    const normalizedAngle = (angle + 360) % 360;

    const timeFromAngle = (angle: number, start: string, end: string) => {
      const startHour = parseInt(start.split(':')[0]);
      const endHour = parseInt(end.split(':')[0]);
      const totalHours = endHour < startHour ? endHour + 24 - startHour : endHour - startHour;
      const anglePerHour = 360 / totalHours;
      
      let hours = Math.floor(angle / anglePerHour);
      const minutes = Math.round((angle % anglePerHour) * 60 / anglePerHour);
      
      hours = (startHour + hours) % 24;
      return `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
    };

    const clickTime = timeFromAngle(normalizedAngle, startTime, endTime);
    onAddTask(clickTime);
  }, [onAddTask, startTime, endTime, isDragging]);

  const currentTimeIndicator = useMemo(() => {
    const now = new Date(currentTime);
    now.setMinutes(now.getMinutes() - now.getTimezoneOffset());
    const userTz = Intl.DateTimeFormat().resolvedOptions().timeZone;
    const targetTz = timezone || userTz;
    const tzOffset = (new Date().getTimezoneOffset() + new Date().getTimezoneOffset()) * 60000;
    now.setTime(now.getTime() + tzOffset);

    const hours = now.getHours();
    const minutes = now.getMinutes();
    const timeString = `${hours.toString().padStart(2, '0')}:${minutes.toString().padStart(2, '0')}`;
    
    const angle = timeToAngle(timeString, startTime, endTime);
    if (angle === null) return null;

    const center = 180;
    const radius = 160;
    const x1 = center + (radius * 0.4) * Math.cos((angle * Math.PI) / 180);
    const y1 = center + (radius * 0.4) * Math.sin((angle * Math.PI) / 180);
    const x2 = center + radius * Math.cos((angle * Math.PI) / 180);
    const y2 = center + radius * Math.sin((angle * Math.PI) / 180);

    return { x1, y1, x2, y2 };
  }, [currentTime, startTime, endTime, timezone]);

  return (
    <div className="relative w-full h-full">
      <svg viewBox="0 0 360 360" className="w-full h-full" style={{ padding: '20px' }}>
        {/* Outer border */}
        <circle cx={180} cy={180} r={160} fill="none" stroke="hsl(var(--border))" strokeWidth="0.5" />
        
        {/* Render Segments */}
        {segments.map((segment) => (
          <g 
            key={segment.id}
            onClick={() => segment.originalTask && handleSegmentClick(segment.originalTask)}
            className="cursor-pointer group"
            onMouseEnter={() => setHoveredSegment(segment.id)}
            onMouseLeave={() => setHoveredSegment(null)}
          >
            <path 
              d={segment.path} 
              fill={segment.color} 
              stroke="hsl(var(--background))" 
              strokeWidth="0.5"
              className="transition-all duration-300 ease-in-out"
              style={{
                opacity: hoveredSegment === null ? 1 : hoveredSegment === segment.id ? 1 : 0.5,
              }}
            />
            <text
              x={segment.textX}
              y={segment.textY}
              textAnchor="middle"
              dominantBaseline="middle"
              fill={isDarkColor(segment.color) ? 'white' : 'black'}
              fontSize="8"
              transform={`rotate(${segment.textRotation}, ${segment.textX}, ${segment.textY})`}
              className="pointer-events-none select-none"
              style={{
                fontSize: '8px',
                fontFamily: 'system-ui, sans-serif',
              }}
            >
              {segment.name}
            </text>
          </g>
        ))}

        {/* Time markers */}
        {Array.from({ length: 12 }).map((_, i) => {
          const angle = (i * 30 * Math.PI) / 180;
          const numberAngle = ((i * 30 - 90) * Math.PI) / 180;
          const radius = 160;
          const numberRadius = radius + 15;
          const x1 = 180 + radius * Math.cos(angle);
          const y1 = 180 + radius * Math.sin(angle);
          const numberX = 180 + numberRadius * Math.cos(numberAngle);
          const numberY = 180 + numberRadius * Math.sin(numberAngle);
          const hour = ((parseInt(startTime) + i * 2) % 24).toString().padStart(2, '0');

          return (
            <g key={i}>
              <line
                x1={180 + radius * 0.95 * Math.cos(angle)}
                y1={180 + radius * 0.95 * Math.sin(angle)}
                x2={x1}
                y2={y1}
                stroke="hsl(var(--border))"
                strokeWidth="0.5"
              />
              <text
                x={numberX}
                y={numberY}
                textAnchor="middle"
                dominantBaseline="middle"
                fill="hsl(var(--foreground))"
                fontSize="10"
                className="select-none"
              >
                {hour}
              </text>
            </g>
          );
        })}

        {/* Current time indicator */}
        {currentTimeIndicator && (
          <line
            x1={currentTimeIndicator.x1}
            y1={currentTimeIndicator.y1}
            x2={currentTimeIndicator.x2}
            y2={currentTimeIndicator.y2}
            stroke="hsl(var(--destructive))"
            strokeWidth="1.5"
            strokeDasharray="4 2"
            className="pointer-events-none"
          />
        )}

        {/* Invisible click area */}
        <circle
          cx={180}
          cy={180}
          r={160}
          fill="transparent"
          className="cursor-crosshair"
          onClick={handleBackgroundClick}
          onMouseDown={() => setIsDragging(true)}
          onMouseUp={() => setIsDragging(false)}
          onMouseLeave={() => setIsDragging(false)}
        />
      </svg>
    </div>
  );
};
